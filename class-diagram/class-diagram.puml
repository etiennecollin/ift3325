@startuml
'skinparam linetype polyline
skinparam nodesep 100

class  "<<struct>>\nClient" as Client{
  - setup_connection(stream: TcpStream, srej: u8,file_path: String) 
  - send_file(tx: mpsc::Sender<Vec<u8>>, file_path: String) : Result<&'static str, &'static str>
}

class  "<<struct>>\nServer" as Server{
  - handle_client(stream: TcpStream, addr: SocketAddr) : Result<bool, &'static str>
  - assembler(mut assembler_rx: mpsc::Receiver<Vec<u8>>, write_tx: mpsc::Sender<Vec<u8>>, addr: SocketAddr) : Result<&'static str, &'static str>
}

  class "<<struct>>\nTunnel" as Tunnel {
  + transmit(data: &[u8]): Result<(), Error>
  + receive(): Result<Vec<u8>, Error>
  + corrupt_frame(frame: Frame) : Result<Frame, Error>
  + drop_frame(frame: Frame) : Result<(), Error>
}

enum FrameType {
  Information : u8
  ConnexionRequest : u8
  ReceiveReady : u8
  Reject : u8
  ConnexionEnd : u8
  P : u8
  Unknown : u8
}

enum FrameError {
  InvalidFrameType : u8
  InvalidFCS : u16
  InvalidLength : u8
  MissingBoundaryFlag : u8
  AbortSequenceReceived : u8
  DestuffingError : u8
  InvalidFrame : u8
}

  class "<<struct>>\nFrame" as Frame {
  + frame_type: u8
  + num: u8
  + data: Vec<u8>
  + fcs: Option<u16>
  + content: Option<Vec<u8>>
  + content_stuffed: Option<Vec<u8>>

  + new(frame_type: u8, num: u8, data: Vec<u8>) : Frame
  + generate_content(&self)
  + to_bytes(&self) : Vec<u8>
  + from_bytes(bytes: &[u8]) : Result<Frame, FrameError>
}

class "<<struct>>\nWindow" as Window {
  const NUMBERING_BITS: usize = 3
  const MAX_FRAME_NUM: u8 = 8
  const FRAME_TIMEOUT: u64 = 3
  const SIZE_GO_BACK_N: usize = 7
  const SIZE_SREJ: usize = 4
  - frames: VecDeque<Frame>
  - resend_all: bool
  - is_connected: bool
  - srej: bool
  - waiting_disconnect: bool
  + new() Self
  + get_size(&self) usize
  + push(&mut self, frame: Frame) Result<(), WindowError>
  + pop_front(&mut self, condition: &SafeCond) Option<Frame>
  + is_full(&self) bool
  + contains(&self, num: u8) bool
  + is_empty(&self) bool
  + pop_until(&mut self, num: u8, inclusive: bool, condition: &SafeCond) usize
  + default() Self
}

enum WindowError {
  Full : u8
  }




  annotation "<<package>>\nCRC" as CRC {
    + lookup_table() : [u16; 256]
    + crc_16_ccitt(data: &[u8]) : u16
  }

  annotation "<<package>>\nIO" as IO {
    + connection_request(window: &SafeWindow, connection_start: bool, srej: Option<u8>, tx: mpsc::Sender<Vec<u8>>, condition: &SafeCond)
    + reader(stream: OwnedReadHalf, window: SafeWindow, condition: SafeCond, writer_tx: Option<mpsc::Sender<Vec<u8>>>, assembler_tx: Option<mpsc::Sender<Vec<u8>>>) : JoinHandle<Result<&'static str, &'static str>>
    + writer(stream: OwnedWriteHalf, rx: mpsc::Receiver<Vec<u8>>) : JoinHandle<Result<&'static str, &'static str>>
    + handle_reception(frame: Frame, safe_window: &SafeWindow, condition: &SafeCond, writer_tx: Option<&mpsc::Sender<Vec<u8>>, assembler_tx: Option<&mpsc::Sender<Vec<u8>>, expected_info_num: &mut u8) : bool
    + flatten<T>(handle: JoinHandle<Result<T, &'static str>>) : Result<T,&'static str> 
    + create_frame_timer(safe_window: SafeWindow, num: u8, tx: mpsc::Sender<Vec<u8>>)
    }


annotation "<<package>>\nByteStuffing" as ByteStuffing {
    + byte_stuffing(frame_bytes: &[u8]) : Vec<u8>
    + byte_destuffing(frame_bytes: &[u8]) : Result<Vec<u8>, FrameError>
  }




Client --> Tunnel : "reçoit les \nframes du client"
Tunnel --> Client : "envoie les \nframes du serveur"
Server --> Tunnel : "reçoit les \nframes du serveur" 
Tunnel --> Server : "envoie les \nframes du client "

Frame --> FrameType : utilise
Frame --> FrameError : utilise

Client --> Frame : utilise
Server --> Frame : utilise
Client --> Window : utilise
Server --> Window : utilise

Window --> WindowError : utilise

Frame --> CRC : utilise
Frame --> ByteStuffing : utilise


Tunnel --> Frame : "corromps\net ou \ndétruit\nou ne fait rien"
'Tunnel -l> Frame : "corromps et ou détruit ou ne fait rien"



Tunnel --> IO : utilise 
Client --> IO : utilise 
Server --> IO : utilise

/'
Utils --|> ByteStuffing : contient
Utils --|> CRC : contient
Utils --|> IO : contient
Utils --|> Frame : contient
Utils --|> Window : contient
'/

@enduml


